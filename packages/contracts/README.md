## Set up

```bash
yarn install
```

## Requirements
- Newer than or equal to `forge 0.2.0 (b174c3a)`.

## Build and Test

Make sure you have [Foundry](https://github.com/foundry-rs/foundry) installed

Build the contracts using the below command.

```bash
$ yarn build
```

Run unit tests
```bash
$ yarn test
```

Run integration tests

Before running integration tests, you need to make a `packages/contracts/test/build_integration` directory, download the zip file from the following link, and place its unzipped directory under that directory.
https://drive.google.com/file/d/13_RItK372JdfQFM3TmQFU_svN7q0k5iF/view?usp=drive_link

Then, move `email_auth.zkey` and `email_auth.wasm` in the unzipped directory `params` to `build_integration`. 


Run each integration tests **one by one** as each test will consume lot of memory.
```bash
Eg: forge test --match-test 'testIntegration_Account_Recovery' -vvv --ffi
```
#### Deploy Common Contracts.
You need to deploy common contracts, i.e., `ECDSAOwnedDKIMRegistry`, `Verifier`, and implementations of `EmailAuth` and `SimpleWallet`, only once before deploying each wallet.
1. `cp .env.sample .env`. 
2. Write your private key in hex to the `PRIVATE_KEY` field in `.env`.
3. `source .env`
4. `forge script script/DeployCommons.s.sol:Deploy --rpc-url $RPC_URL --chain-id $CHAIN_ID --broadcast -vvvv`

#### Deploy Each Wallet.
After deploying common contracts, you can deploy a proxy contract of `SimpleWallet`, which is an example contract supporting our email-based account recovery.
1. Check that the env values of `DKIM`, `VERIFIER`, `EMAIL_AUTH_IMPL`, and `SIMPLE_WALLET_IMPL` are the same as those output by the `DeployCommons.s.sol` script.
2. `forge script script/DeploySimpleWallet.s.sol:Deploy --rpc-url $RPC_URL --chain-id $CHAIN_ID --broadcast -vvvv` 

## Specification
There are four main contracts that developers should understand: `IDKIMRegistry`, `Verifier`, `EmailAuth` and `EmailAccountRecovery`.
While the first three contracts are agnostic to usecases of our SDK, the last one is an abstract contract only for our email-based account recovery.

### `IDKIMRegistry` Contract
It is an interface of the DKIM registry contract that traces public keys registered for each email domain in DNS.
It is defined in [the zk-email library](https://github.com/zkemail/zk-email-verify/blob/main/packages/contracts/interfaces/IDKIMRegistry.sol).
It requires a function `isDKIMPublicKeyHashValid(string domainName, bytes32 publicKeyHash) view returns (bool)`: it returns true iff the given hash of the public key `publicKeyHash` is registered for the given email-domain name `domainName`.

One of its implementations is [`ECDSAOwnedDKIMRegistry`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/ECDSAOwnedDKIMRegistry.sol).
It stores the Ethereum address `signer` who can update the registry.

### `Verifier` Contract
It has a responsibility to verify a ZK proof for the [`email_auth.circom` circuit](https://github.com/zkemail/ether-email-auth/blob/main/packages/circuits/src/email_auth.circom).
It is implemented in [`utils/Verifier.sol`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/Verifier.sol).

It defines a structure `EmailProof` consisting of the ZK proof and data of the instances necessary for proof verification as follows:
```
struct EmailProof {
    string domainName; // Domain name of the sender's email
    bytes32 publicKeyHash; // Hash of the DKIM public key used in email/proof
    uint timestamp; // Timestamp of the email
    string maskedSubject; // Masked subject of the email
    bytes32 emailNullifier; // Nullifier of the email to prevent its reuse.
    bytes32 accountSalt; // Create2 salt of the account
    bool isCodeExist; // Check if the account code is exist
    bytes proof; // ZK Proof of Email
}
```

Using that, it provides a function `function verifyEmailProof(EmailProof memory proof) public view returns (bool)`: it takes as input the `EmailProof proof` and returns true iff the proof is valid. Notably, it internally calls [`Groth16Verifier.sol`](https://github.com/zkemail/ether-email-auth/blob/main/packages/contracts/src/utils/Groth16Verifier.sol) generated by snarkjs from the verifying key of the [`email_auth.circom` circuit](https://github.com/zkemail/ether-email-auth/blob/main/packages/circuits/src/email_auth.circom).

### `EmailAuth` Contract
It is a contract deployed for each email user to verify an email-auth message from that user. The structure of the email-auth message is defined as follows:
```
struct EmailAuthMsg {
    uint templateId; // The ID of the subject template that the email subject should satisfy.
    bytes[] subjectParams; // The parameters in the email subject, which should be taken according to the specified subject template.
    uint skipedSubjectPrefix; // The number of skiiped bytes in the email subject.
    EmailProof proof; // The email proof containing the zk proof and other necessary information for the email verification by the verifier contract.
}
``` 

It has the following storage variables.
- `address owner`: an address of the contract owner.
- `bytes32 accountSalt`: an `accountSalt` used for the CREATE2 salt of this contract.
- `DKIMRegistry dkim`: an instance of the DKIM registry contract.
- `Verifier verifier`: an instance of the Verifier contract.
- `mapping(uint=>string[]) subjectTemplates`: a mapping of the supported subject templates associated with its ID.  
- `mapping(bytes32⇒bytes32) authedHash`: a mapping of the hash of the authorized message associated with its `emailNullifier`. 
- `uint lastTimestamp`: the latest `timestamp` in the verified `EmailAuthMsg`. 
- `mapping(bytes32=>bool) usedNullifiers`: a mapping storing the used `emailNullifier` bytes. 
- `bool timestampCheckEnabled`: a boolean whether timestamp check is enabled or not.

It provides the following functions.
- `initialize(address _initialOwner, bytes32 _accountSalt)`
    1. Set `owner=_initialOwner` .
    2. Set `accountSalt=_accountSalt`.
    3. Set `timestampCheckEnabled=true`.
- `updateDKIMRegistry(address _dkim)`
    1. Assert `msg.sender==owner`.
    2. Assert `_dkim` is not zero.
    3. Set `dkim=DKIMRegistry(_dkim)`.
- `updateVerifier(address _verifier)`
    1. Assert `msg.sender==owner`.
    2. Assert `_verifier` is not zero.
    3. Set `verifier=Verifier(_verifier)`.
- `dkimRegistryAddr() view returns (address)`
    Return `address(dkim)`
- `verifierAddr() view returns (address)`
    Return `address(verifier)` .
- `updateVerifier(address _verifierAddr)`
    1. Assert `msg.sender==owner` .
    2. Assert `_verifierAddr!=0`.
    3. Update `verifier` to `Verifier(_verifierAddr)`.
- `updateDKIMRegistry(address _dkimRegistryAddr)`
    1. Assert `msg.sender==owner` .
    2. Assert `_dkimRegistryAddr!=0`.
    3. Update `dkim` to `DKIMRegistry(_dkimRegistryAddr)`.
- `insertSubjectTemplate(uint _templateId, string[] _subjectTemplate)`
    1. Assert `_subjectTemplate.length>0` .
    2. Assert `msg.sender==owner`.
    3. Assert `subjectTemplates[_templateId].length == 0`, i.e., no template has not been registered with `_templateId`.
    4. Set  `subjectTemplates[_templateId]=_subjectTemplate`.
- `updateSubjectTemplate(uint _templateId, string[] _subjectTemplate)`
    1. Assert `_subjectTemplate.length>0` .
    2. Assert `msg.sender==owner`.
    3. Assert `subjectTemplates[_templateId].length != 0` , i.e., any template has been already registered with `_templateId`.
    4. Set  `subjectTemplates[_templateId]=_subjectTemplate`.
- `deleteSubjectTemplate(uint _templateId)`
    1. Assert `msg.sender==owner`.
    2. Assert `subjectTemplates[_templateId].length > 0`, i.e., any template has been already registered with `_templateId`.
    3. `delete subjectTemplates[_templateId]`.
- `computeMsgHash(bytes32 accountSalt, bool isCodeExist, uint templateId, bytes[] subjectParams) public view returns (bytes32)`
    1. Return `keccak256(accountAddr, templateId, isCodeExist, subjectParams)`
- `authEmail(EmailAuthMsg emailAuthMsg) returns (bytes32)`
    1. Assert `msg.sender==owner`.
    2. Let `string[] memory template = subjectTemplates[emailAuthMsg.templateId]`.
    3. Assert `template.length > 0`.
    4. Assert `dkim.isDKIMPublicKeyHashValid(emailAuthMsg.proof.domain, emailAuthMsg.proof.publicKeyHash)==true`.
    5. Assert `usedNullifiers[emailAuthMsg.proof.emailNullifier]==false` and set `usedNullifiers[emailAuthMsg.proof.emailNullifier]` to `true`. 
    6. Assert `accountSalt==emailAuthMsg.proof.accountSalt`.
    7. If `timestampCheckEnabled` is true, assert that `emailAuthMsg.proof.timestamp` is zero OR `lastTimestamp < emailAuthMsg.proof.timestamp`, and update `lastTimestamp` to `emailAuthMsg.proof.timestamp`.
    8. Construct an expected subject `expectedSubject` from `template` and the values of `emailAuthMsg.subjectParams`.
    9. Assert that `expectedSubject` is equal to `emailAuthMsg.proof.maskedSubject[skipedSubjectPrefix:]` , i.e., the string of `emailAuthMsg.proof.maskedSubject` from the `skipedSubjectPrefix`-th byte.
    10. Assert `verifier.verifyEmailProof(emailAuthMsg.proof)==true`.
    11. Compute `bytes32 msgHash = computeMsgHash(emailAuthMsg.proof.accountSalt, emailAuthMsg.proof.isCodeExist, emailAuthMsg.templateId, emailAuthMsg.subjectParams)`. 
    12. Set `authedHash[emailAuthMsg.proof.emailNullifier]=msgHash`.
    13. Return `msgHash`.
- `isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue)`
    1. Parse `_signature` as `(bytes32 emailNullifier)`.
    2. If `authedHash[emailNullifier]== _hash`, return `0x1626ba7e`; otherwise return `0xffffffff`.
- `setTimestampCheckEnabled(bool enabled) public`
    1. Assert `msg.sender==owner`.
    2. Set `timestampCheckEnabled` to `enabled`.

### `EmailAccountRecovery` Contract
It is an abstract contract for each wallet contract to implement our email-based account recovery. **Each wallet provider only needs to implement the following functions in the wallet contract.**
- `acceptanceSubjectTemplates() public view virtual returns (string[][])`: it returns multiple subject templates for an email to accept becoming a guardian.
- `recoverySubjectTemplates() public view virtual returns (string[][])`: it returns multiple subject templates for an email to confirm the account recovery.
- `acceptGuardian(address guardian, uint templateIdx, bytes[] subjectParams, bytes32 emailNullifier) internal virtual`: it takes as input the Ethereum address `guardian` corresponding to the guardian's email address, the index `templateIdx` of the subject template in the output of `acceptanceSubjectTemplates()`, the parameter values of the variable parts `subjectParams` in the template `acceptanceSubjectTemplates()[templateIdx]`, and an email nullifier `emailNullifier`. It is called after verifying the email-auth message to accept the role of the guardian; thus you can assume the arguments are already verified. 
- `processRecovery(address guardian, uint templateIdx, bytes[] subjectParams, bytes32 emailNullifier) internal virtual`: it takes as input the Ethereum address `guardian` corresponding to the guardian's email address, the index `templateIdx` of the subject template in the output of `recoverySubjectTemplates()`, the parameter values of the variable parts `subjectParams` in the template `recoverySubjectTemplates()[templateIdx]`, and an email nullifier `emailNullifier`. It is called after verifying the email-auth message to confirm the recovery; thus you can assume the arguments are already verified.
- `completeRecovery() external virtual`: it can be called by anyone, in particular a Relayer, when completing the account recovery. It should first check if the condition for the account recovery holds and then update the owner address in the wallet contract.

It also provides the following entry functions with their default implementations, called by the Relayer.
- `handleAcceptance(EmailAuthMsg emailAuthMsg, uint templateIdx) external`
    1. Let `address guardian = CREATE2(emailAuthMsg.proof.accountSalt, ERC1967Proxy.creationCode, emailAuthImplementation(), (emailAuthMsg.proof.accountSalt))`.
    2. Assert that the contract of `guardian` has not been deployed.
    3. Let `uint templateId = keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "ACCEPTANCE", templateIdx)`.
    4. Assert that  `templateId` is equal to `emailAuthMsg.templateId`.
    5. Assert that `emailAuthMsg.proof.isCodeExist` is true.
    6. Deploy the proxy contract of `emailAuthImplementation()`. Its salt is `emailAuthMsg.proof.accountSalt` and its initialization parameter is  `mailAuthMsg.proof.accountSalt`.
    7. Call `EmailAuth(guardian).setDkim(dkim())`.
    8. Call `EmailAuth(guardian).setVerifier(verifier())`.
    9. For each `template` in `acceptanceSubjectTemplates()` along with its index `idx`, call `EmailAuth(guardian).insertSubjectTemplate(keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "ACCEPTANCE", idx), template)`.
    10. For each `template` in `recoverySubjectTemplates()` along with its index `idx`, call `EmailAuth(guardian).insertSubjectTemplate(keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "RECOVERY", idx), template)`.
    11. Assert that `EmailAuth(guardian).authEmail(1emailAuthMsg)` returns no error.
    12. Call `acceptGuardian(guardian, templateIdx, emailAuthMsg.subjectParams, emailAuthMsg.proof.emailNullifier)`.
- `handleRecovery(EmailAuthMsg emailAuthMsg, uint templateIdx) external`
    1. Let `address guardian = CREATE2(emailAuthMsg.proof.accountSalt, ERC1967Proxy.creationCode, emailAuthImplementation(), (emailAuthMsg.proof.accountSalt))`.
    2. Assert that the contract of `guardian` has been already deployed.
    3. Let `uint templateId=keccak256(EMAIL_ACCOUNT_RECOVERY_VERSION_ID, "RECOVERY", templateIdx)`.
    4. Assert that  `templateId` is equal to `emailAuthMsg.templateId`.
    5. Assert that `EmailAuth(guardian).authEmail(emailAuthMsg)` returns no error.
    6. Call `processRecovery(guardian, templateIdx, emailAuthMsg.subjectParams, emailAuthMsg.proof.emailNullifier)`.

# For zksync

You should use foundry-zksync, the installation process is following URL.
https://github.com/matter-labs/foundry-zksync

Current version foundry-zksync is forge 0.0.2 (13497a5 2024-05-16T00:24:48.304138000Z)
They can't use solc 0.8.25, so you should set appreciate solc version in foundry.toml.
For ex. 

```
solc = "0.8.23"
```

Also the current foundry-zksync does not work correctly if your svm has 0.8.25 installed.
In that case, please do the following:

For Apple Silicon

```
rm -rf  ~/Library/Application\ Support/svm/0.8.25
```

Or you can use docker too.

```
docker run -d -it -v $PWD:$PWD --name zksync-development --platform linux/amd64 ubuntu
docker exec -it zksync-development bash
```

In the docker container, you should execute following commands.

```
apt update
apt -y install git curl nodejs npm
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
curl -L https://foundry.paradigm.xyz | bash
source ~/.bashrc
git clone https://github.com/matter-labs/foundry-zksync.git
cd foundry-zksync
chmod +x ./install-foundry-zksync
./install-foundry-zksync
cd /Users/wataru_shinohara/GitHub/zkemail/ether-email-auth
yarn
cd packages/contracts
```

At the first forge build, you got the following warning.

```
┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Warning: Your code or one of its dependencies uses the 'extcodesize' instruction, which is       │
│ usually needed in the following cases:                                                           │
│   1. To detect whether an address belongs to a smart contract.                                   │
│   2. To detect whether the deploy code execution has finished.                                   │
│ zkSync Era comes with native account abstraction support (so accounts are smart contracts,       │
│ including private-key controlled EOAs), and you should avoid differentiating between contracts   │
│ and non-contract addresses.                                                                      │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘
--> ../../node_modules/forge-std/src/StdCheats.sol

Failed to compile with zksolc: Missing libraries detected [ZkMissingLibrary { contract_name: "SubjectUtils", contract_path: "src/libraries/SubjectUtils.sol", missing_libraries: ["src/libraries/DecimalUtils.sol:DecimalUtils"] }, ZkMissingLibrary { contract_name: "DecimalUtils", contract_path: "src/libraries/DecimalUtils.sol", missing_libraries: [] }]
```

Please run the following command in order to deploy the missing libraries:

```
forge create --deploy-missing-libraries --private-key <PRIVATE_KEY> --rpc-url <RPC_URL> --chain <CHAIN_ID> --zksync
forge create --deploy-missing-libraries --private-key {YOUR_PRIVATE_KEY} --rpc-url https://sepolia.era.zksync.dev --chain 300 --zksync
```

The above command output the following(for example):

```
[⠊] Compiling...
No files changed, compilation skipped
Deployer: 0xfB1CcCBDa2C41a77cDAC448641006Fc7fcf1f3b9
Deployed to: 0x91cc0f0A227b8dD56794f9391E8Af48B40420A0b
Transaction hash: 0x4f94ab71443d01988105540c3abb09ed66f8af5d0bb6a88691e2dafa88b3583d
[⠢] Compiling...
[⠃] Compiling 68 files with 0.8.23
[⠆] Solc 0.8.23 finished in 12.20s
Compiler run successful!
Deployer: 0xfB1CcCBDa2C41a77cDAC448641006Fc7fcf1f3b9
Deployed to: 0x981E3Df952358A57753C7B85dE7949Da4aBCf54A
Transaction hash: 0xfdca7b9eb3ae933ca123111489572427ee95eb6be74978b24c73fe74cb4988d7
```

After that, you can see the following line in foundry.toml.
Also, this line is needed only for foundry-zksync, if you use foundry, please remove this line. Otherwise, the test will fail.

```
libraries = ["{PROJECT_DIR}/packages/contracts/src/libraries/DecimalUtils.sol:DecimalUtils:{DEPLOYED_ADDRESS}", "{PROJECT_DIR}/packages/contracts/src/libraries/SubjectUtils.sol:SubjectUtils:{DEPLOYED_ADDRESS}"]

```

About Create2, `L2ContractHelper.computeCreate2Address` should be used.
And `type(ERC1967Proxy).creationCode` doesn't work correctly.
We need to hardcode the `type(ERC1967Proxy).creationCode` to bytecodeHash.
Perhaps that is different value in each compiler version.

You should replace the following line to the correct hash.
packages/contracts/src/EmailAccountRecovery.sol:L94 

See, test/ComputeCreate2Address.t.sol

# For zksync testing

Current foundry-zksync overrides the foundry behavior. If you installed foundry-zksync, some EVM code will be different and some test cases will be failed. If you want to test on other EVM, please install foundry.

Even if the contract size is fine for EVM, it may exceed the bytecode size limit for zksync, and the test may not be executed.
Therefore, EmailAccountRecovery.t.sol has been splited.

Currently some test cases are not work correctly because there is a issue about missing libraries.

Failing test cases are here.

- testAuthEmail()
- testExpectRevertAuthEmailEmailNullifierAlreadyUsed() 
- testExpectRevertAuthEmailInvalidEmailProof()
- testExpectRevertAuthEmailInvalidSubject()
- testExpectRevertAuthEmailInvalidTimestamp()
- testIsValidSignature()
- testIsValidSignatureReturnsFalse()

# For zksync deployment (For test net)

You need to edit .env at first.
Second just run the following commands with `--zksync`

```
source .env
forge script script/DeployCommons.s.sol:Deploy --zksync --rpc-url $SEPOLIA_RPC_URL --broadcast -vvvv
```

